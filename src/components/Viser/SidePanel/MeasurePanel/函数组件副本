/* eslint-disable react/jsx-props-no-spreading */
import * as React from 'react';
import * as THREE from 'three';

// import { Box, Typography, Tab, Tabs, Button } from '@mui/material';
import { LevaPanel, LevaStoreProvider, useCreateStore } from 'leva';
import BlurOnIcon from '@mui/icons-material/BlurOn';
import CategoryIcon from '@mui/icons-material/Category';
import LevaTheme from '../../../themes/leva_theme.json';
import { useDispatch, useSelector, connect } from 'react-redux';
import { Button, Flex, Input, Statistic, Table, Space } from 'antd';
// import { useEffect, useState } from 'antd';
import { render } from '@testing-library/react';
import {
  ViserWebSocketContext,
  sendWebsocketMessage,
} from '../../WebSocket/ViserWebSocket';
// import type { ColumnsType, TableProps } from 'antd/es/table';
import { AppContext } from '../../../../pages/ShowModel/App'


// type MyProps = {
//   sceneTree : Object
//   handleSend: any;
// }
// type MyState = {
//   samplePoints : {
//     startPoint : { x:number, y:number },
//     endPoint: { x:number, y:number },
//   },
//   sampleDistance: number,
//   measurePoints : {
//     startPoint : { x:number, y:number },
//     endPoint: { x:number, y:number },
//   },
//   measureTargetName: '',
//   isMeasuring: false,
// }
// interface DataType {
//   key: React.Key;
//   name: string;
//   real_world_length: number;
// }

const columns = [
  {
    title: '名称',
    dataIndex: 'name',
  },
  {
    title: '长度',
    dataIndex: 'real_world_length',
    sorter: (a, b) =>  a.real_world_length - b.real_world_length,
  },
]
export default function MeasurePanel(props) {
  
  
  const [samplePoints, setSamplePoints] = React.useState({startPoint: { x: 0, y: 0 }, endPoint: { x: 0, y: 0 }});
  const [sampleDistance, setSampleDistance] = React.useState(0);
  const [measurePoints, setMeasurePoints] = React.useState({startPoint: { x: 0, y: 0 }, endPoint: { x: 0, y: 0 }});
  const [measureTargetName, setMeasureTargetName] = React.useState('');
  const [isMeasuring, setIsMeasuring] = React.useState(false);

  const viser_websocket = React.useContext(ViserWebSocketContext);
  const sceneTree = props.sceneTree;

  const dispatch = useDispatch();

  const target_length_sequence = useSelector(
    (state)=>state.target_length_sequence
  )

  
  
  const calculateLength=()=>{
      
      const resolution = useSelector((state)=>state.renderingState.eval_res,) 
      const cleanedString = resolution.replace(/x/g, ' ');
      const cleanedString2 = cleanedString.replace(/p/g, '');
      const [height, width] = cleanedString2.split(' ').map(Number);
      console.log(width,height)
      const measure_points = [];
      measure_points.push(measurePoints.startPoint.x * width)
      measure_points.push(measurePoints.startPoint.y * height)
      measure_points.push(measurePoints.endPoint.x * width)
      measure_points.push(measurePoints.endPoint.y * height)
      console.log(measure_points)

      const render_height = useSelector((state)=>state.renderingState.render_height,);
      const render_width = useSelector((state)=>state.renderingState.render_width,);
      const render_aspect = render_width/render_height;
      const old_camera_matrix = sceneTree.metadata.camera.matrix.elements.slice();
      const camera_type = useSelector((state)=>state.renderingState.camera_type,);
      const is_moving = false;
  
      sendWebsocketMessage(viser_websocket, {
        type: 'CalculateLengthMessage',
        samplePoints: measure_points,
        name: measureTargetName,
  
        aspect: sceneTree.metadata.camera.aspect,
        render_aspect,
        fov: sceneTree.metadata.camera.fov,
        matrix: old_camera_matrix,
        camera_type,
        is_moving,
        timestamp: +new Date(),
      });
    }

  const calculateScale=()=>{
    const resolution = useSelector((state)=>state.renderingState.eval_res,) 
    const cleanedString = resolution.replace(/x/g, ' ');
    const cleanedString2 = cleanedString.replace(/p/g, '');
    const [height, width] = cleanedString2.split(' ').map(Number);
    console.log(width,height)
    const sample_points = [];
    sample_points.push(samplePoints.startPoint.x * width)
    sample_points.push(samplePoints.startPoint.y * height)
    sample_points.push(samplePoints.endPoint.x * width)
    sample_points.push(samplePoints.endPoint.y * height)
    console.log(sample_points)

    const render_height = useSelector((state)=>state.renderingState.render_height,);
    const render_width = useSelector((state)=>state.renderingState.render_width,);
    const render_aspect = render_width/render_height;
    const old_camera_matrix = sceneTree.metadata.camera.matrix.elements.slice();
    const camera_type = useSelector((state)=>state.renderingState.camera_type,);
    const is_moving = false;

    dispatch({
      type: 'write',
      path: 'is_canvas_visible',
      data: isMeasuring,
    });

    sendWebsocketMessage(viser_websocket, {
      type: 'SampleScaleMessage',
      samplePoints: sample_points,
      real_sample_distance: sampleDistance,

      aspect: sceneTree.metadata.camera.aspect,
      render_aspect,
      fov: sceneTree.metadata.camera.fov,
      matrix: old_camera_matrix,
      camera_type,
      is_moving,
      timestamp: +new Date(),
    });
  }

  const sampleLine=(e)=> {
    // console.log(e)
      e.stopPropagation();
      const size = new THREE.Vector2();
      sceneTree.metadata.renderer.getSize(size);
      setIsMeasuring((prev)=> true)
      if (sceneTree.scene_state.mouse_in_scene == false) {
        alert("请在渲染窗口内取点")
        return;
      }
      if (sampleDistance == 0 ){
        window.removeEventListener('dblclick',sampleLine,false);
        alert("您还未输入采样线段长度")
        return;
      }
      if (samplePoints.startPoint.y==0)
      { 
        const newX = e.clientX / size.x;
        const newY = (e.clientY - 50) / size.y;
        const newStartPoint ={...samplePoints.startPoint,x:newX,y:newY};
        const newState = {
          ...samplePoints,
          startPoint:newStartPoint
        }
        // setSamplePoints(()=>{Object.assign(...samplePoints,{startPoint:{x:newX,y:newY}})});
        setSamplePoints(newState,(prev,newv)=>{console.log(newv)})
        console.log(1)
        console.log(samplePoints)
        return;
      } else if (samplePoints.startPoint.y!=0 && samplePoints.endPoint.y==0) {
        const newX = e.clientX / size.x;
        const newY = (e.clientY - 50) / size.y;
        setSamplePoints(()=>{Object.assign(...samplePoints,{endPoint:{x:newX,y:newY}})});

        console.log(2)
        console.log(samplePoints)
        return;
      } else {
          // dispatch({
          //   type: 'sample',
          //   data: samplePoints,
          // });
        
        setSamplePoints(()=>{Object.assign(...samplePoints,{startPoint:{x:newX,y:newY},endPoint:{x:0,y:0}})});
        
        console.log(3)
        console.log(samplePoints)
        calculateScale()
        window.removeEventListener('dblclick',sampleLine,false);
        
      }
    }

    const measureLine=(e)=> {
      // console.log(e)
        e.stopPropagation();
        const size = new THREE.Vector2();
        sceneTree.metadata.renderer.getSize(size);
        if (measureTargetName == '') {
          window.removeEventListener('dblclick',measureLine,false);
          alert('您还未输入测量目标名称');
        }
        if (measurePoints.startPoint.y==0)
        { 
          const newX = e.clientX / size.x;
          const newY = (e.clientY - 50) / size.y;
          setMeasurePoints(()=>{Object.assign(...measurePoints,{startPoint:{x:newX,y:newY}})})
        
          console.log(1)
          console.log(measurePoints)
          return;
        } else if (measurePoints.startPoint.y!=0 && measurePoints.endPoint.y==0) {
          const newX = e.clientX / size.x;
          const newY = (e.clientY - 50) / size.y;
          setMeasurePoints(()=>{Object.assign(...measurePoints,{endPoint:{x:newX,y:newY}})})
          
          console.log(2)
          console.log(measurePoints)
          return;
        } else {
            // dispatch({
            //   type: 'sample',
            //   data: samplePoints,
            // });
          
          setMeasurePoints(()=>{Object.assign(...measurePoints,{startPoint:{x:newX,y:newY},endPoint:{x:0,y:0}})});
  
          calculateLength()
          window.removeEventListener('dblclick',measureLine,false);
          // setStep(()=>0);
          // setOpenMeasureSample(!openMeasureSample)
        }
      }

    const handleSampleDistanceChange=(e)=>{
      setSampleDistance(()=>{const distance=e.target.value;return distance;})
      // this.setState(()=>{Object.assign(this.state,{sampleDistance: e.target.value})})
    }
    const handleMeasureTargetNameChange=(e)=>{
      setMeasureTargetName(()=>{const target_name=e.target.value;return target_name;})
      // this.setState(()=>{Object.assign(this.state,{measureTargetName: e.target.value})})
    }

    return(
      
      <div className="MeasurePanel">
          <div className='MeasurePanel-top-row' >
              <div className='MeasurePanel-action-sample' style={{display: 'flex',justifyContent:'start',marginTop:'20px',marginLeft:'10px'}}>
                <Space.Compact>
                  <Input style={{width:'240px'}} placeholder='采样线段真实长度 (单位: m)'  onChange={handleSampleDistanceChange}></Input>
                  <Button onClick={(event)=>{window.addEventListener('dblclick',sampleLine,false)}}>采样</Button>
                </Space.Compact>
            
              </div>
              
              {/* <div className='MeasurePanel-scale'>
                <Statistic title='尺度' value={112} ></Statistic>

              </div> */}
          </div>
        
          <div className="MeasurePanel-measure">
            <div className="MeasurePanel-action-measure" style={{display: 'flex',justifyContent:'start',marginTop:'50px',marginLeft:'10px'}}>
              <Space.Compact>
                <Input style={{width:'240px'}} placeholder='请输入测量目标的名字' onChange={handleMeasureTargetNameChange}></Input>
              </Space.Compact>
              <Button onClick={(event)=>{window.addEventListener('dblclick',measureLine,false)}}>
                  测量
              </Button>
            </div>
            
          </div>
          <div className='MeasurePanel-length' style={{marginTop:'50px'}}>
              <div>
                <Table columns={columns} dataSource={target_length_sequence.slice(1)} ></Table>
              </div>
          </div>
          
      </div>
    )  
  }
  
